
## 第9章 コレクション ーネストを解消する構造化技法ー

**コレクションとは？**
コレクションとは、たくさんの要素をひとつのユニットに集めた単なるオブジェクト。
入れ物を表すコンテナと呼ばれることもある。

一般的なコレクションの種類には：

- **リスト（配列）** - 順序が決まっているデータの集まり。例えば `[1, 2, 3, 4, 5]` という数字のリスト。
- **セット** - 重複しない、順序のないデータの集まり。例えば `{りんご、みかん、バナナ}` のような一意なもののセット。
- **マップ（辞書）** - キーと値のペアで管理するもの。例えば `{名前: "太郎", 年齢: 25}` のように対応させて保存。
### 9.1 自前でコレクション処理を実装してしまう

▼「牢屋の鍵」の所持を調べつコード：for文の中にif文がネストされていてやや見通しにくい。
```java
boolean hasPrisonKey = false;
// itemsはList<Item>型
for (Item each : items){
	if(each.name.equals("牢屋の鍵")){
		hasPrisonKey = true;
		break;
	}
}
```

▼anyMatchメソッド
```java
boolean hasPrisonKey = items.stream().anyMatch(item -> item.name.equals("牢屋の鍵"));
//stream()：コレクション（Listなど）に“操作するための流れ”を作る
//anyMatch()：「1つでも条件に合うものがあれば true」
```
anyMatchメソッドはJavaの標準ライブラリに用意されているコレクション用メソッド。
条件を満たす要素がコレクションに1つでも含まれている場合trueを返す。

anyMatchを知っていれば、複雑なロジックを時前で実装する必要はない。逆に知らなければ、わざわざ自前で実装しなければならず、無駄にロジックが複雑になってしまう。 ←無知は罪と言いたいのか…？ 

for文を使ってコレクション処理をする場合は、==標準ライブライに同じような機能のメソッドがないか、まず探してみることが大事。==

#### ちなみに…
Laravelに置き換えるとこんな感じらしい
```php
$hasPrisonKey = $items->contains('name', '牢屋の鍵');
//$items が Eloquent モデルやオブジェクトのコレクションの場合
```

#### Column 車輪の再発明
広く使われ確率している解決方法があるにもかかわらず、それを知らずに、また意図的に無視して、同じような解決方法を作り出してしまうことを**車輪の再発明**と呼ぶ。
すでに確立している技術を使わないと、新たに作り出す労力や時間が無駄になってしまう。更に、すでにあるものよりも役に立たないものを作り出すことを**四角い車輪の再発明**と呼ぶ。実績のあるライブラリがあるのに、知らずに時前で実装し、そのつくりが未熟であるためにバグを発生させてしまうケースもある。
車輪の再発明による弊害を避けるため、サービス開発においては、フレームワークの機能やライブラリを丁寧に調査することが重要。
学習目的で、あえて車輪の再発明をやってみるのはいい。動作のしくみや根拠を理解することで、技術力を高め、開発を豊かにするから。

### 9.2 ループ処理の条件分岐ネスト
コレクション内で、特定の条件を満たす要素だけに何らかの処理をしたい場合について。

RPGにおける、毒によるダメージを例にしてみる。
メンバー全員の状態を調べ、毒に侵されている場合にはHPを減少させるロジックを考える。

▼ダメな例
```java
for (Member member : members){
	if(0 < member.hitPoint){ // 生存しているかを調べる
		if(member.containsState(StateType.poison){　//　毒に侵されているかを調べる
			member.hitPoint -= 10; //毒に侵されていればHPを10減らす
			if(member.hitPoint <= 0){ //HPが0以下の場合
				member.hitPoint = 0; //HPを0に補正
				member.addState(StateType.dead);　//戦闘不能状態にする
				member.removeState(StateType.poison);
			}
		})
	}
}
```
if文がネストしていてこ＝、コードの見通しが悪い
#### 9.2.1 continueで条件分岐のネストを解消する
ループ処理の条件分岐ネストは、continueで解決可能。continueは、ループの先頭に戻って次の処理を続ける制御構文。8.1の早期returnの考え方を応用し、「条件を満たさない場合にcontinueでループの先頭に戻る」書き方に買える。

▼continueでネスト解消
```java
for (Member member : members){

	//生存していない場合continueでループの先頭に戻る。
	//continueの使用にあたり、条件を反転させる。
	if(member.hitPoint == 0) continue;
	
	if(member.containsState(StateType.poison){
		member.hitPoint -= 10; //毒に侵されていればHPを10減らす
			if(member.hitPoint <= 0){ //HPが0以下の場合
				member.hitPoint = 0; //HPを0に補正
				member.addState(StateType.dead);　//戦闘不能状態にする
				member.removeState(StateType.poison);
			}
	}
}
```
生存していない場合は、continueにより後続の処理は実行されず、次のメンバーについてのループ処理が実行される。

他のif文にもcontinueを使うと
```java
for (Member member : members){

	//生存していない場合continueでループの先頭に戻る。
	//continueの使用にあたり、条件を反転させる。
	if(member.hitPoint == 0) continue;
	
	//
	if(! member.containsState(StateType.poison) continue;
	
	member.hitPoint -= 10; //HPを10減らす
	
	if(0 < member.hitPoint) continue; //生存していれば次のループへ
	
	member.hitPoint = 0; //HPを0に補正
	member.addState(StateType.dead);　//戦闘不能状態にする
	member.removeState(StateType.poison);//毒のステータス解除
	}
	
}
```

if文の三重ネストが解消され、コードの見通しがよくなった。

#### 9.2.2 breakもネスト解消に役立つ
### 9.3 バラバラなコレクション処理
#### 9.3.1 コレクション処理をカプセル化する
#### 9.3.2 外部へ渡す場合はコレクションを変更できなくする