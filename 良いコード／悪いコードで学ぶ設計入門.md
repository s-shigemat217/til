## 第1章 悪しき構造の弊害を知覚する
## 第2章 設計の初歩
## 第3章 カプセル化の基礎
## 第4章 不変の活用
## 第5章 バラバラなデータとロジックをカプセル化する実践技法
## 第6章 関心の分離という考え方
## 第7章 関心が混ざったコードを分けて整理する実践技法
## 第8章 条件分岐 
## 第9章 コレクション ーネストを解消する構造化技法ー

**コレクションとは？**
コレクションとは、たくさんの要素をひとつのユニットに集めた単なるオブジェクト。
入れ物を表すコンテナと呼ばれることもある。

一般的なコレクションの種類には：

- **リスト（配列）** - 順序が決まっているデータの集まり。例えば `[1, 2, 3, 4, 5]` という数字のリスト。
- **セット** - 重複しない、順序のないデータの集まり。例えば `{りんご、みかん、バナナ}` のような一意なもののセット。
- **マップ（辞書）** - キーと値のペアで管理するもの。例えば `{名前: "太郎", 年齢: 25}` のように対応させて保存。
### 9.1 自前でコレクション処理を実装してしまう

▼「牢屋の鍵」の所持を調べつコード：for文の中にif文がネストされていてやや見通しにくい。
```java
boolean hasPrisonKey = false;
// itemsはList<Item>型
for (Item each : items){
	if(each.name.equals("牢屋の鍵")){
		hasPrisonKey = true;
		break;
	}
}
```

▼anyMatchメソッド
```java
boolean hasPrisonKey = items.stream().anyMatch(item -> item.name.equals("牢屋の鍵"));
//stream()：コレクション（Listなど）に“操作するための流れ”を作る
//anyMatch()：「1つでも条件に合うものがあれば true」
```
anyMatchメソッドはJavaの標準ライブラリに用意されているコレクション用メソッド。
条件を満たす要素がコレクションに1つでも含まれている場合trueを返す。

anyMatchを知っていれば、複雑なロジックを自前で実装する必要はない。逆に知らなければ、わざわざ自前で実装しなければならず、無駄にロジックが複雑になってしまう。 ←無知は罪と言いたいのか…？ 

for文を使ってコレクション処理をする場合は、==標準ライブライに同じような機能のメソッドがないか、まず探してみることが大事。==

#### ちなみに…
Laravelに置き換えるとこんな感じらしい
```php
$hasPrisonKey = $items->contains('name', '牢屋の鍵');
//$items が Eloquent モデルやオブジェクトのコレクションの場合
```

#### Column 車輪の再発明
広く使われ確率している解決方法があるにもかかわらず、それを知らずに、また意図的に無視して、同じような解決方法を作り出してしまうことを**車輪の再発明**と呼ぶ。
すでに確立している技術を使わないと、新たに作り出す労力や時間が無駄になってしまう。更に、すでにあるものよりも役に立たないものを作り出すことを**四角い車輪の再発明**と呼ぶ。実績のあるライブラリがあるのに、知らずに時前で実装し、そのつくりが未熟であるためにバグを発生させてしまうケースもある。
車輪の再発明による弊害を避けるため、サービス開発においては、フレームワークの機能やライブラリを丁寧に調査することが重要。
学習目的で、あえて車輪の再発明をやってみるのはいい。動作のしくみや根拠を理解することで、技術力を高め、開発を豊かにするから。

---

### 9.2 ループ処理の条件分岐ネスト
コレクション内で、特定の条件を満たす要素だけに何らかの処理をしたい場合について。

RPGにおける、毒によるダメージを例にしてみる。
メンバー全員の状態を調べ、毒に侵されている場合にはHPを減少させるロジックを考える。

▼ダメな例
```java
for (Member member : members){
	if(0 < member.hitPoint){ // 生存しているかを調べる
		if(member.containsState(StateType.poison){　//　毒に侵されているかを調べる
			member.hitPoint -= 10; //毒に侵されていればHPを10減らす
			if(member.hitPoint <= 0){ //HPが0以下の場合
				member.hitPoint = 0; //HPを0に補正
				member.addState(StateType.dead);　//戦闘不能状態にする
				member.removeState(StateType.poison);
			}
		})
	}
}
```
if文がネストしていてこ＝、コードの見通しが悪い
#### 9.2.1 continueで条件分岐のネストを解消する
ループ処理の条件分岐ネストは、continueで解決可能。continueは、ループの先頭に戻って次の処理を続ける制御構文。8.1の早期returnの考え方を応用し、「条件を満たさない場合にcontinueでループの先頭に戻る」書き方に買える。

▼continueでネスト解消
```java
for (Member member : members){

	//生存していない場合continueでループの先頭に戻る。
	//continueの使用にあたり、条件を反転させる。
	if(member.hitPoint == 0) continue;
	
	if(member.containsState(StateType.poison){
		member.hitPoint -= 10; //毒に侵されていればHPを10減らす
			if(member.hitPoint <= 0){ //HPが0以下の場合
				member.hitPoint = 0; //HPを0に補正
				member.addState(StateType.dead);　//戦闘不能状態にする
				member.removeState(StateType.poison);
			}
	}
}
```
生存していない場合は、continueにより後続の処理は実行されず、次のメンバーについてのループ処理が実行される。

他のif文にもcontinueを使うと
```java
for (Member member : members){

	//生存していない場合continueでループの先頭に戻る。
	//continueの使用にあたり、条件を反転させる。
	if(member.hitPoint == 0) continue;
	
	//
	if(! member.containsState(StateType.poison) continue;
	
	member.hitPoint -= 10; //HPを10減らす
	
	if(0 < member.hitPoint) continue; //生存していれば次のループへ
	
	member.hitPoint = 0; //HPを0に補正
	member.addState(StateType.dead);　//戦闘不能状態にする
	member.removeState(StateType.poison);//毒のステータス解除
	}
	
}
```

if文の三重ネストが解消され、コードの見通しがよくなった。
#### 9.2.2 breakもネスト解消に役立つ
ループ処理の制御構文には、continue以外にもbreakがある。breakは処理を中断し、ループから抜け出す制御構文。早期returnと同様に、breakによりコードの単純化が可能な場合がある。

同様にRPGの連携攻撃を例にシステムを想定。連携攻撃では攻撃力増幅などの効果がある一方、連携成功条件が厳しく、なかなか成功しないと言った特徴があるものとする。
計算は以下の仕様
- メンバーの先頭から順に連携攻撃の成否を評価する
- 連携に成功した場合
	- そのメンバーの攻撃力×1.1倍を加算ダメージ値とする
- 連携に失敗した場合
	- 以後後続メンバーの連携も評価しない
- 加算ダメージ値が30以上の場合
	- 加算ダメージ値をダメージに加算する
- 加算ダメージ値が30未満の場合
	- 連携失敗とみなす。以後後続メンバーの連携も評価しない
▼複雑にネストした見通しの悪いコード
```java
int totalDamage = 0;
for (Member member : members){
	if(member.hasTeamAttackSucceeded()){
		int damage = (int)(member.attack() * 1.1);
		if(30 <= damage){
			totalDamage += damage;
		}else{
			break;
		}
	}else{
		break;
	}
}

```

▼if文の条件を反転してbreakすることで、コードのみ通りを改善
```java
int totalDamage = 0;
for (Member member : members){
	if(! member.hasTeamAttackSucceeded()) break; //連携に成功していなければbreak
	
	int damage = (int)(member.attack() * 1.1);
	
	if(damage < 30) break; //加算ダメージ値が30未満の場合、break
	
	totalDamage += damage;
}
```

ループ処理の中でif文のネストを書いてしまいそうなときは、continueやbreakを使って構造を単純にできないか検討しよう。

---
### 9.3 バラバラなコレクション処理
▼リスト9.8：メンバー操作の知識を持つクラス（NG例）
```java
class FeildManager{
	//メンバーを追加する
	void addMember(List<Member> members, Member newMember){
		if (members.strem().anyMatch(member -> member.id == newMember.id)){
			throw new RuntimeException("既にパーティに加わっています。");
		}
		if (members.size() == MEX_MEMBER_COUNT){
			throw new RuntimeException("これ以上メンバーを追加できません。");
		}
	}
	
	members.add(newMember);
}

//パーティメンバーが1人でも生存している場合trueを返す。
boolean partyIsAlive(List<Member> members){
	return members.stream().anyMatch(member -> member.isAlive());
}
```
FieldManagerはフィールドマップ上の制御を担当するクラス。パーティにメンバーを追加するaddMemberメソッドと、パーティメンバーが生存しているかを買えるpartyAliveメソッドが定義されている。
ゲーム中、メンバーが追加されるタイミングはフィールドマップ中だけではない。重要イベント中に仲間が追加されるロジックが、上のように実装されるかもしれない。

▼リスト9.9：別のクラスに実装される重複コード
```java
class SpecialEventManager{
	//メンバーを追加する
	void addMember(List<Member> members, Member newMember){
		members.add(member);
	}
}
```
SpecialEventManagerは、ゲーム中の特別イベントを制御するクラス。FieldManagerと同様のメンバー追加メソッドaddMemberが、SpecialEventManagerにも実装されている重複コード。

▼リスト9.10：また別の箇所にも重複コードが…
```java
class BattleManager {
	//パーティメンバーが一人でも生存している場合trueを返す。
	boolean memberAreAlive(List<Member> members){
		boolean result = false;
		for(Member each : members){
			if(each.isAlive()){
				result = true;
				break;
			}
		}
	}
}
```
BattleManagerクラスのmembersAliveメソッドは、FieldManagerクラスのpartyIsAliveメソッドとロジックの振る舞いが同じで、見かけだけが異なる重複コード。
#### 9.3.1 コレクション処理をカプセル化する
この問題を解決するのがファーストクラスコレクション（First Class Collection）。
コレクションに関連するロジックをカプセル化する設計パターン。

クラスには以下の2つが備わっている必要がある。
- インスタンス変数
- 完全性を保証するようにインスタンス変数を操作するメソッド

ファーストクラスコレクションは、この考え方の応用で、次の2つの要素で構成するクラスとして設計される。
- コレクション型インスタンス変数
- 完全性を保証するようにコレクション型インスタンス変数を操作するメソッド


メンバーのコレクションList < Member > をインスタンツ変数に持つクラスを設計します。メンバーの集まりは「パーティ」と呼ばれるので、このクラスをPartyと命名。

▼リスト9.11：リスト型をインスタンス変数として持つ
```java
class Party{
	private final List<Member> members;
	
	Party(){
		members = new ArrayList<Member>();
	}
}
```

次に、インスタンス変数を操作するロジックをこのPartyクラスに移動。
メンバー追加用のaddMemberメソッドを、addメソッドと命名してPartyへ移動する。

▼リスト9.12：membersの変化は副作用となる
```java
class Party{
	//中略
	void add(final Member newMember){
		members.add(newMember);
	}
}
```
このコードでは要素の追加によってmembersの状態が変化している。即ち、副作用が発生する。
副作用を防ぐために新しいリストを生成し、そのリストへ追加するつくりにする。

▼9.13 副作用が生じないメソッド
```java
class Party{
	//中略
	Party add(final Member newMember){
		final List<Member> adding = new ArrayList<>(members);
		adding.add(newMember);
		return new Party(adding);
	}
}
```



▼リスト9.14：リスト操作に必要なロジックを同じクラスに定義
```java
class　Party{
	static final int MAX_MEMBER_COUNT = 4;
	private final List<Member> members;
	
	Party(){
		members = new ArrayList<Member>();
	}
	
	private Party(List<Member> members){
		this.members = members;
	}
	
	/**
	 * メンバーを追加する
	 * @param newMember 追加したいメンバー
	 * @return メンバー追加後のパーティ
	 */
	Party add(final Member newMember){
		if(exists(newMember)){
			throw new RuntimeException("既にパーティに加わっています。");
		}
		if(isFull()){
			throw new RuntimeException("これ以上メンバーを追加できません。");
		}
		
		final List<Member> adding = new ArrayList<>(members);
		adding.add(newMember);
		return new Party(adding);
	}
	
	/** @return パーティのメンバーが一人でも生存している場合true */
	boolean isAlive(){
		return members.stream().anyMatch(each -> each.isAlive());
	}
	
	/**
	 * @param member パーティに所属しているかを調べたいメンバー
	 * @return すでに所属している場合true
	 */
	 boolean exist(final Member member){
		 return members.stream().anyMatch(each -> each.id == member.id);
	 }
	 
	 /** @return パーティが満員の場合true */
	 boolean isFull(){
		 return members.size() == MAX_MEMBER_COUNT;
	 }
}
```

ここの節でいいたいのは、**ファーストクラスコレクション**。
ファーストクラスコレクションとは、**そのコレクションに関するロジックとルールを全部そのクラスに入れる**という設計パターン。

ファーストクラスコレクションを使う理由
1. 配列（List）があちこちで勝手に書き換えられると危険
2. コレクションにまつわるロジックが散らばって壊れやすいから
3. コレクションは “本来ルールを持った集合” なのに、配列として扱うと意味が失われるから

なので、Partyというクラスを作る（＝コレクションをカプセル化）
Partyクラスの中に、
- Member の集合（コレクション）
- コレクションを操作するメソッド
	- add()：メンバーの追加
	- isAlive：パーティの生存確認
	- exists：パーティの所属確認
	- isFull：パーティの満員確認
を1つにまとめている。＝カプセル化
#### 9.3.2 外部へ渡す場合はコレクションを変更できなくする

パーティメンバー全員のステータスを画面表示する場合などは、List< Member >を参照する必要がある。メンバー全員を参照する場合、リスト9.15のようなメソッドを定義していいか。否。
▼9.15 リスト型をそのまま帰すメソッド
```java
class Party{
	List<Member> members(){
		return members;
	}
}
```
インスタンス変数をそのまま外部へ渡すと、Partyクラスの外部でメンバー追加したり削除したり、勝手な操作を許してしまう。カプセル化した意味がない。

外部へ渡す際は、コレクション要素の追加や削除をできなくする。

▼9.17 外部には普遍にして渡す
```java
class Party{
	List<Member> members(){
		return members.unmodifiableList()
	}
}
```
unmodifiableListで得たコレクションは、要素の変更や削除ができない。Partyクラスの外部で勝手に変更されてしまう心配がない。
**unmodifiableList：外側から add/remove できない、読み取り専用の List を作るメソッド**


### まとめ
コレクションのカプセル化とは、  
配列をそのまま外に渡すと危険だから、  
専用クラス（Party）に閉じ込めて、  
外から勝手に変更できないようにする設計手法。

## 第10章 設計の健全性をそこなうさまざまな悪魔たち
## 第11章 名前設計
## 第12章 コメント
## 第13章 メソッド（関数）
## 第14章 モデリング
## 第15章 リファクタリング ー既存コードを成長に導く技ー
## 第16章 設計の意義と設計への向き合い方
## 第17章 設計を妨げる開発の進み方との戦い
## 第18章 設計技術の理解の深め方